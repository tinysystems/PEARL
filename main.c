/**
 * @file        main.c
 * @brief       GPIO Example
 * @details
 */

/******************************************************************************
 * Copyright (C) 2022 Maxim Integrated Products, Inc., All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Maxim Integrated
 * Products, Inc. shall not be used except as stated in the Maxim Integrated
 * Products, Inc. Branding Policy.
 *
 * The mere transfer of this software does not imply any licenses
 * of trade secrets, proprietary technology, copyrights, patents,
 * trademarks, maskwork rights, or any other form of intellectual
 * property whatsoever. Maxim Integrated Products, Inc. retains all
 * ownership rights.
 *
 ******************************************************************************/

/***** Includes *****/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "mxc_device.h"
#include "mxc_errors.h"
#include "nvic_table.h"
#include "board.h"
#include "gpio.h"
#include "lp.h"
#include "rtc.h"
#include "icc.h"
#include "simo.h"
#include "pb.h"
#include "uart.h"
#include "led.h"
#include "mxc_delay.h"
#include "flc.h"
#include "flc_regs.h"
#include "gcr_regs.h"
#include "sdhc.h"
#include "example_config.h"
#include "tmr.h"
#include "rtc.h"
#include "core1.h"

/***** Definitions *****/

#define SINGLE_CORE_EXPERIMENT 1
#define DUAL_CORE_EXPERIMENT 1
#define ADAPTIVE_EXPERIMENT 1

#define INPUT_HEIGHT 32
#define INPUT_WIDTH 32

#define KERNEL_HEIGHT 2
#define KERNEL_WIDTH 2

#define OUTPUT_HEIGHT 31
#define OUTPUT_WIDTH 31

/***** Globals *****/

float input[INPUT_HEIGHT][INPUT_WIDTH] = {
                             {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x56, 0x11, 0x25},
                             {0x28, 0x00, 0x00, 0x03, 0x10, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x35, 0xd2, 0xdd, 0x6a, 0x5c, 0x55, 0x14, 0x00, 0xe0, 0xf5, 0xb7, 0xf7, 0x39, 0x67, 0xa6, 0x99, 0x4c, 0xa2, 0x13, 0x63, 0x91},
                             {0x54, 0xa9, 0x7f, 0x01, 0x15, 0x6f, 0x44, 0xa8, 0x14, 0x54, 0xd0, 0x1b, 0x7d, 0x00, 0x9f, 0xc2, 0x1b, 0x1f, 0xc3, 0x1b, 0x5f, 0xc3, 0x2b, 0x85, 0x5e, 0x4b, 0x05, 0xa1, 0xa5, 0x42, 0xc0, 0x0b},
                             {0x89, 0x50, 0x85, 0xd4, 0x90, 0xff, 0x4e, 0x9a, 0xcc, 0x64, 0x66, 0xce, 0x39, 0x7b, 0xef, 0xb5, 0x96, 0x57, 0x7e, 0xcf, 0xf0, 0xe1, 0x6b, 0x1f, 0x00, 0x00, 0x12, 0x30, 0x98, 0xb9, 0x99, 0x83},
                             {0x23, 0x38, 0x31, 0x00, 0x32, 0x4b, 0x90, 0xc7, 0xf2, 0xfe, 0x77, 0x85, 0x98, 0x28, 0x44, 0xd6, 0x9c, 0xb5, 0x37, 0x70, 0x33, 0x10, 0x01, 0xa0, 0x50, 0xd5, 0xa3, 0xb5, 0x6f, 0xa5, 0x7b, 0x61},
                             {0x10, 0x22, 0x57, 0x1a, 0x40, 0x4d, 0x51, 0xd5, 0x5c, 0x0d, 0xc9, 0x0d, 0x25, 0x84, 0xd9, 0x70, 0x25, 0xe9, 0xc6, 0x3d, 0xd4, 0x15, 0xa2, 0x93, 0x9a, 0x3b, 0x98, 0x66, 0x55, 0x20, 0x50, 0x24},
                             {0x88, 0xc9, 0xb2, 0xa4, 0x2b, 0xa2, 0xda, 0x81, 0x3c, 0x30, 0x98, 0xaa, 0x59, 0x51, 0x2d, 0x06, 0xe8, 0x88, 0x96, 0x8b, 0x67, 0x29, 0x9d, 0x04, 0x55, 0xcb, 0x08, 0x86, 0x00, 0xee, 0x60, 0x8e},
                             {0xee, 0xe6, 0x60, 0x40, 0x86, 0x5d, 0x11, 0x57, 0xa4, 0x44, 0xd9, 0x55, 0x08, 0x11, 0x2c, 0xa9, 0x9a, 0x9b, 0x19, 0x82, 0x15, 0x14, 0x07, 0x15, 0x57, 0x67, 0x6d, 0x41, 0x88, 0x00, 0x80, 0xa0},
                             {0x14, 0x05, 0x53, 0x42, 0x00, 0x2b, 0x96, 0xb0, 0x14, 0xf1, 0x3c, 0x20, 0xcf, 0x4e, 0x19, 0x63, 0xee, 0x31, 0x5a, 0x9b, 0x24, 0x50, 0x88, 0xe4, 0x59, 0xf3, 0x0a, 0xa1, 0x08, 0xe7, 0xab, 0x00},
                             {0x41, 0x96, 0x7d, 0xa8, 0xc1, 0xa5, 0x6d, 0x97, 0x7d, 0xdd, 0x44, 0x19, 0xbc, 0xda, 0xcc, 0x4f, 0xa6, 0xa9, 0xae, 0x8a, 0x00, 0x26, 0xb0, 0x3e, 0x14, 0x84, 0xae, 0x50, 0x0c, 0x1c, 0x91, 0x0b},
                             {0xf0, 0xf6, 0x7b, 0xeb, 0x83, 0xee, 0xe9, 0x83, 0x6b, 0x48, 0xd2, 0xcd, 0x48, 0x41, 0x08, 0x72, 0xc7, 0xdc, 0x5e, 0x33, 0x85, 0xda, 0x2d, 0xed, 0xee, 0x5e, 0x1e, 0x9e, 0xe8, 0xc6, 0xc3, 0xed},
                             {0x50, 0x24, 0xad, 0xa8, 0x42, 0x2d, 0x9e, 0x5a, 0xe3, 0x94, 0xa1, 0x1e, 0x96, 0xd6, 0xbf, 0xbe, 0xff, 0xfb, 0x83, 0xd7, 0x3f, 0xbe, 0xfb, 0xc3, 0xbe, 0xdd, 0x75, 0xa1, 0x40, 0x98, 0x32, 0xab},
                             {0x86, 0x18, 0xea, 0xf6, 0x45, 0x49, 0x3d, 0x7d, 0xf5, 0xf9, 0xb3, 0xd9, 0x37, 0x3b, 0xab, 0x9f, 0x1e, 0x6e, 0x1c, 0xae, 0xa2, 0x00, 0x14, 0xae, 0x43, 0xbf, 0xfe, 0xe6, 0xce, 0x5b, 0x93, 0x91},
                             {0x9f, 0x1f, 0x3e, 0x6f, 0x5f, 0xf9, 0x2c, 0xd2, 0xb0, 0xe3, 0xb3, 0x93, 0x3b, 0x47, 0x9d, 0x0c, 0xa4, 0xc3, 0x2d, 0xbd, 0x9e, 0x9e, 0x7c, 0xba, 0x76, 0x67, 0xb7, 0xa7, 0x9b, 0xf1, 0x8e, 0x00},
                             {0xe4, 0xec, 0x93, 0xe5, 0xcd, 0xde, 0xec, 0xf6, 0xfd, 0x47, 0x4f, 0x02, 0xde, 0xda, 0xda, 0x39, 0x3f, 0x5b, 0x8d, 0x26, 0xf9, 0xc7, 0x77, 0x9e, 0x9d, 0x4d, 0xdf, 0x78, 0xb7, 0x22, 0x2c, 0xf3},
                             {0xd9, 0x68, 0x7c, 0xf0, 0xfd, 0x6a, 0xc8, 0x17, 0xff, 0x9e, 0x4a, 0x75, 0x79, 0xe0, 0xc8, 0x3a, 0xfb, 0x70, 0xfd, 0x72, 0x71, 0xf0, 0xe4, 0xa3, 0xf0, 0xb2, 0x60, 0x39, 0x3a, 0x98, 0xbc, 0x7d},
                             {0x73, 0x0e, 0xf3, 0xae, 0xbf, 0x05, 0x12, 0xef, 0xfc, 0x9d, 0xe1, 0xf6, 0xc6, 0xaa, 0x9c, 0x37, 0x57, 0xfb, 0xbf, 0x1d, 0x9e, 0x7d, 0x02, 0x2d, 0xee, 0xed, 0x7f, 0x79, 0x5c, 0xaf, 0x3f, 0x25},
                             {0x76, 0x57, 0x29, 0xb6, 0x35, 0x1b, 0x8f, 0x6b, 0xed, 0xff, 0x3a, 0xff, 0xf3, 0x74, 0x6d, 0xfa, 0xf3, 0xde, 0xa6, 0x87, 0xe9, 0x3f, 0x7c, 0xef, 0x68, 0xd2, 0xff, 0xb1, 0xbd, 0x36, 0x37, 0x5c},
                             {0x1b, 0xa3, 0x08, 0x51, 0xfd, 0x05, 0xfc, 0x32, 0x7d, 0x69, 0xdc, 0xe0, 0x74, 0xe9, 0x16, 0xc3, 0xf8, 0xde, 0xf4, 0xd7, 0xd1, 0x31, 0x8f, 0x86, 0x07, 0x82, 0xa1, 0xe1, 0x84, 0xb8, 0x73, 0x75},
                             {0xec, 0x4d, 0x8d, 0x89, 0x87, 0xba, 0x14, 0xc9, 0x17, 0x8f, 0xab, 0x80, 0xc3, 0xc5, 0x3c, 0xf5, 0x42, 0x91, 0xd5, 0x6d, 0xd0, 0x3f, 0x2a, 0x52, 0x73, 0x9b, 0x82, 0x25, 0xd4, 0x54, 0xec, 0x62},
                             {0x73, 0x6d, 0x14, 0x2a, 0x0d, 0x24, 0x86, 0x0e, 0x48, 0x78, 0x8a, 0x21, 0x0e, 0xf3, 0x8a, 0x63, 0x36, 0xf4, 0x02, 0x9e, 0xae, 0xf5, 0x7a, 0xd0, 0xb8, 0x99, 0x48, 0xa3, 0xad, 0xd5, 0x18, 0x53},
                             {0x4e, 0xa4, 0x8a, 0x2d, 0x86, 0xc4, 0xbd, 0x36, 0xb8, 0x02, 0x5e, 0x78, 0xd1, 0x24, 0x79, 0x0e, 0xd9, 0x22, 0x0a, 0x72, 0xfb, 0xbc, 0xa2, 0xbe, 0x54, 0x83, 0xd8, 0x75, 0x9e, 0xfe, 0x2f, 0x6c},
                             {0xe2, 0x49, 0x55, 0x3a, 0x1b, 0x4a, 0x9f, 0xd9, 0xfb, 0x9e, 0x90, 0xb8, 0x40, 0x71, 0xab, 0x63, 0x66, 0xcd, 0xee, 0x92, 0x17, 0xe2, 0xe6, 0xb4, 0xb4, 0xc2, 0x9b, 0x32, 0x75, 0x96, 0xd2, 0x15},
                             {0xac, 0x18, 0xa1, 0x73, 0xd2, 0x62, 0x2a, 0x60, 0x86, 0x0a, 0x92, 0x82, 0xe4, 0x79, 0x28, 0xbe, 0xb0, 0xc8, 0xc4, 0x2c, 0x64, 0xad, 0x06, 0x8c, 0x9b, 0x17, 0x02, 0x90, 0xab, 0x26, 0x98, 0x1a},
                             {0xe5, 0x12, 0x81, 0x5b, 0xd5, 0x8a, 0x34, 0x87, 0xba, 0x81, 0x85, 0x54, 0xd9, 0x4d, 0xc8, 0x1c, 0x2a, 0xea, 0xad, 0x38, 0x85, 0xe8, 0x30, 0xc9, 0x5e, 0xf7, 0x8a, 0x8e, 0x30, 0x6c, 0xa2, 0xdf},
                             {0x2c, 0x5a, 0x14, 0x76, 0x62, 0x04, 0x57, 0xc3, 0x18, 0xad, 0x07, 0x62, 0x56, 0x37, 0xe5, 0xc6, 0x0d, 0xcd, 0xad, 0xfd, 0x0f, 0x16, 0x21, 0x00, 0x0e, 0xb0, 0x15, 0x1d, 0x95, 0x82, 0x25, 0xd4},
                             {0x54, 0xec, 0x62, 0x73, 0x6d, 0x14, 0x2a, 0x0d, 0x24, 0x86, 0x0e, 0x48, 0x78, 0x8a, 0x21, 0x0e, 0xf3, 0x8a, 0x63, 0x36, 0xf4, 0x02, 0x9e, 0xae, 0xf5, 0x7a, 0xd0, 0xb8, 0x99, 0x48, 0xa3, 0xad},
                             {0xd5, 0x18, 0x53, 0x4e, 0xa4, 0x8a, 0x2d, 0x86, 0xc4, 0xbd, 0x36, 0xb8, 0x02, 0x5e, 0x78, 0xd1, 0x24, 0x79, 0x0e, 0xd9, 0x22, 0x0a, 0x72, 0xfb, 0xbc, 0xa2, 0xbe, 0x54, 0x83, 0xd8, 0x75, 0x9e},
                             {0xfe, 0x2f, 0x6c, 0xe2, 0x49, 0x55, 0x3a, 0x1b, 0x4a, 0x9f, 0xd9, 0xfb, 0x9e, 0x90, 0xb8, 0x40, 0x71, 0xab, 0x63, 0x66, 0xcd, 0xee, 0x92, 0x17, 0xe2, 0xe6, 0xb4, 0xb4, 0xc2, 0x9b, 0x32, 0x75},
                             {0x96, 0xd2, 0x15, 0xac, 0x18, 0xa1, 0x73, 0xd2, 0x62, 0x2a, 0x60, 0x86, 0x0a, 0x92, 0x82, 0xe4, 0x79, 0x28, 0xbe, 0xb0, 0xc8, 0xc4, 0x2c, 0x64, 0xad, 0x06, 0x8c, 0x9b, 0x17, 0x02, 0x90, 0xab},
                             {0x26, 0x98, 0x1a, 0xe5, 0x12, 0x81, 0x5b, 0xd5, 0x8a, 0x34, 0x87, 0xba, 0x81, 0x85, 0x54, 0xd9, 0x4d, 0xc8, 0x1c, 0x2a, 0xea, 0xad, 0x38, 0x85, 0xe8, 0x30, 0xc9, 0x5e, 0xf7, 0x8a, 0x8e, 0x30},
                             {0x6c, 0xa2, 0xdf, 0x2c, 0x5a, 0x14, 0x76, 0x62, 0x04, 0x57, 0xc3, 0x18, 0xad, 0x07, 0x62, 0x56, 0x37, 0xe5, 0xc6, 0x0d, 0xcd, 0xad, 0xfd, 0x0f, 0x16, 0x21, 0x00, 0x0e, 0xb0, 0x15, 0x1d, 0x95}
};

float input1[INPUT_HEIGHT][INPUT_WIDTH] = {
                             {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x56, 0x11, 0x25},
                             {0x28, 0x00, 0x00, 0x03, 0x10, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x35, 0xd2, 0xdd, 0x6a, 0x5c, 0x55, 0x14, 0x00, 0xe0, 0xf5, 0xb7, 0xf7, 0x39, 0x67, 0xa6, 0x99, 0x4c, 0xa2, 0x13, 0x63, 0x91},
                             {0x54, 0xa9, 0x7f, 0x01, 0x15, 0x6f, 0x44, 0xa8, 0x14, 0x54, 0xd0, 0x1b, 0x7d, 0x00, 0x9f, 0xc2, 0x1b, 0x1f, 0xc3, 0x1b, 0x5f, 0xc3, 0x2b, 0x85, 0x5e, 0x4b, 0x05, 0xa1, 0xa5, 0x42, 0xc0, 0x0b},
                             {0x89, 0x50, 0x85, 0xd4, 0x90, 0xff, 0x4e, 0x9a, 0xcc, 0x64, 0x66, 0xce, 0x39, 0x7b, 0xef, 0xb5, 0x96, 0x57, 0x7e, 0xcf, 0xf0, 0xe1, 0x6b, 0x1f, 0x00, 0x00, 0x12, 0x30, 0x98, 0xb9, 0x99, 0x83},
                             {0x23, 0x38, 0x31, 0x00, 0x32, 0x4b, 0x90, 0xc7, 0xf2, 0xfe, 0x77, 0x85, 0x98, 0x28, 0x44, 0xd6, 0x9c, 0xb5, 0x37, 0x70, 0x33, 0x10, 0x01, 0xa0, 0x50, 0xd5, 0xa3, 0xb5, 0x6f, 0xa5, 0x7b, 0x61},
                             {0x10, 0x22, 0x57, 0x1a, 0x40, 0x4d, 0x51, 0xd5, 0x5c, 0x0d, 0xc9, 0x0d, 0x25, 0x84, 0xd9, 0x70, 0x25, 0xe9, 0xc6, 0x3d, 0xd4, 0x15, 0xa2, 0x93, 0x9a, 0x3b, 0x98, 0x66, 0x55, 0x20, 0x50, 0x24},
                             {0x88, 0xc9, 0xb2, 0xa4, 0x2b, 0xa2, 0xda, 0x81, 0x3c, 0x30, 0x98, 0xaa, 0x59, 0x51, 0x2d, 0x06, 0xe8, 0x88, 0x96, 0x8b, 0x67, 0x29, 0x9d, 0x04, 0x55, 0xcb, 0x08, 0x86, 0x00, 0xee, 0x60, 0x8e},
                             {0xee, 0xe6, 0x60, 0x40, 0x86, 0x5d, 0x11, 0x57, 0xa4, 0x44, 0xd9, 0x55, 0x08, 0x11, 0x2c, 0xa9, 0x9a, 0x9b, 0x19, 0x82, 0x15, 0x14, 0x07, 0x15, 0x57, 0x67, 0x6d, 0x41, 0x88, 0x00, 0x80, 0xa0},
                             {0x14, 0x05, 0x53, 0x42, 0x00, 0x2b, 0x96, 0xb0, 0x14, 0xf1, 0x3c, 0x20, 0xcf, 0x4e, 0x19, 0x63, 0xee, 0x31, 0x5a, 0x9b, 0x24, 0x50, 0x88, 0xe4, 0x59, 0xf3, 0x0a, 0xa1, 0x08, 0xe7, 0xab, 0x00},
                             {0x41, 0x96, 0x7d, 0xa8, 0xc1, 0xa5, 0x6d, 0x97, 0x7d, 0xdd, 0x44, 0x19, 0xbc, 0xda, 0xcc, 0x4f, 0xa6, 0xa9, 0xae, 0x8a, 0x00, 0x26, 0xb0, 0x3e, 0x14, 0x84, 0xae, 0x50, 0x0c, 0x1c, 0x91, 0x0b},
                             {0xf0, 0xf6, 0x7b, 0xeb, 0x83, 0xee, 0xe9, 0x83, 0x6b, 0x48, 0xd2, 0xcd, 0x48, 0x41, 0x08, 0x72, 0xc7, 0xdc, 0x5e, 0x33, 0x85, 0xda, 0x2d, 0xed, 0xee, 0x5e, 0x1e, 0x9e, 0xe8, 0xc6, 0xc3, 0xed},
                             {0x50, 0x24, 0xad, 0xa8, 0x42, 0x2d, 0x9e, 0x5a, 0xe3, 0x94, 0xa1, 0x1e, 0x96, 0xd6, 0xbf, 0xbe, 0xff, 0xfb, 0x83, 0xd7, 0x3f, 0xbe, 0xfb, 0xc3, 0xbe, 0xdd, 0x75, 0xa1, 0x40, 0x98, 0x32, 0xab},
                             {0x86, 0x18, 0xea, 0xf6, 0x45, 0x49, 0x3d, 0x7d, 0xf5, 0xf9, 0xb3, 0xd9, 0x37, 0x3b, 0xab, 0x9f, 0x1e, 0x6e, 0x1c, 0xae, 0xa2, 0x00, 0x14, 0xae, 0x43, 0xbf, 0xfe, 0xe6, 0xce, 0x5b, 0x93, 0x91},
                             {0x9f, 0x1f, 0x3e, 0x6f, 0x5f, 0xf9, 0x2c, 0xd2, 0xb0, 0xe3, 0xb3, 0x93, 0x3b, 0x47, 0x9d, 0x0c, 0xa4, 0xc3, 0x2d, 0xbd, 0x9e, 0x9e, 0x7c, 0xba, 0x76, 0x67, 0xb7, 0xa7, 0x9b, 0xf1, 0x8e, 0x00},
                             {0xe4, 0xec, 0x93, 0xe5, 0xcd, 0xde, 0xec, 0xf6, 0xfd, 0x47, 0x4f, 0x02, 0xde, 0xda, 0xda, 0x39, 0x3f, 0x5b, 0x8d, 0x26, 0xf9, 0xc7, 0x77, 0x9e, 0x9d, 0x4d, 0xdf, 0x78, 0xb7, 0x22, 0x2c, 0xf3},
                             {0xd9, 0x68, 0x7c, 0xf0, 0xfd, 0x6a, 0xc8, 0x17, 0xff, 0x9e, 0x4a, 0x75, 0x79, 0xe0, 0xc8, 0x3a, 0xfb, 0x70, 0xfd, 0x72, 0x71, 0xf0, 0xe4, 0xa3, 0xf0, 0xb2, 0x60, 0x39, 0x3a, 0x98, 0xbc, 0x7d},
                             {0x73, 0x0e, 0xf3, 0xae, 0xbf, 0x05, 0x12, 0xef, 0xfc, 0x9d, 0xe1, 0xf6, 0xc6, 0xaa, 0x9c, 0x37, 0x57, 0xfb, 0xbf, 0x1d, 0x9e, 0x7d, 0x02, 0x2d, 0xee, 0xed, 0x7f, 0x79, 0x5c, 0xaf, 0x3f, 0x25},
                             {0x76, 0x57, 0x29, 0xb6, 0x35, 0x1b, 0x8f, 0x6b, 0xed, 0xff, 0x3a, 0xff, 0xf3, 0x74, 0x6d, 0xfa, 0xf3, 0xde, 0xa6, 0x87, 0xe9, 0x3f, 0x7c, 0xef, 0x68, 0xd2, 0xff, 0xb1, 0xbd, 0x36, 0x37, 0x5c},
                             {0x1b, 0xa3, 0x08, 0x51, 0xfd, 0x05, 0xfc, 0x32, 0x7d, 0x69, 0xdc, 0xe0, 0x74, 0xe9, 0x16, 0xc3, 0xf8, 0xde, 0xf4, 0xd7, 0xd1, 0x31, 0x8f, 0x86, 0x07, 0x82, 0xa1, 0xe1, 0x84, 0xb8, 0x73, 0x75},
                             {0xec, 0x4d, 0x8d, 0x89, 0x87, 0xba, 0x14, 0xc9, 0x17, 0x8f, 0xab, 0x80, 0xc3, 0xc5, 0x3c, 0xf5, 0x42, 0x91, 0xd5, 0x6d, 0xd0, 0x3f, 0x2a, 0x52, 0x73, 0x9b, 0x82, 0x25, 0xd4, 0x54, 0xec, 0x62},
                             {0x73, 0x6d, 0x14, 0x2a, 0x0d, 0x24, 0x86, 0x0e, 0x48, 0x78, 0x8a, 0x21, 0x0e, 0xf3, 0x8a, 0x63, 0x36, 0xf4, 0x02, 0x9e, 0xae, 0xf5, 0x7a, 0xd0, 0xb8, 0x99, 0x48, 0xa3, 0xad, 0xd5, 0x18, 0x53},
                             {0x4e, 0xa4, 0x8a, 0x2d, 0x86, 0xc4, 0xbd, 0x36, 0xb8, 0x02, 0x5e, 0x78, 0xd1, 0x24, 0x79, 0x0e, 0xd9, 0x22, 0x0a, 0x72, 0xfb, 0xbc, 0xa2, 0xbe, 0x54, 0x83, 0xd8, 0x75, 0x9e, 0xfe, 0x2f, 0x6c},
                             {0xe2, 0x49, 0x55, 0x3a, 0x1b, 0x4a, 0x9f, 0xd9, 0xfb, 0x9e, 0x90, 0xb8, 0x40, 0x71, 0xab, 0x63, 0x66, 0xcd, 0xee, 0x92, 0x17, 0xe2, 0xe6, 0xb4, 0xb4, 0xc2, 0x9b, 0x32, 0x75, 0x96, 0xd2, 0x15},
                             {0xac, 0x18, 0xa1, 0x73, 0xd2, 0x62, 0x2a, 0x60, 0x86, 0x0a, 0x92, 0x82, 0xe4, 0x79, 0x28, 0xbe, 0xb0, 0xc8, 0xc4, 0x2c, 0x64, 0xad, 0x06, 0x8c, 0x9b, 0x17, 0x02, 0x90, 0xab, 0x26, 0x98, 0x1a},
                             {0xe5, 0x12, 0x81, 0x5b, 0xd5, 0x8a, 0x34, 0x87, 0xba, 0x81, 0x85, 0x54, 0xd9, 0x4d, 0xc8, 0x1c, 0x2a, 0xea, 0xad, 0x38, 0x85, 0xe8, 0x30, 0xc9, 0x5e, 0xf7, 0x8a, 0x8e, 0x30, 0x6c, 0xa2, 0xdf},
                             {0x2c, 0x5a, 0x14, 0x76, 0x62, 0x04, 0x57, 0xc3, 0x18, 0xad, 0x07, 0x62, 0x56, 0x37, 0xe5, 0xc6, 0x0d, 0xcd, 0xad, 0xfd, 0x0f, 0x16, 0x21, 0x00, 0x0e, 0xb0, 0x15, 0x1d, 0x95, 0x82, 0x25, 0xd4},
                             {0x54, 0xec, 0x62, 0x73, 0x6d, 0x14, 0x2a, 0x0d, 0x24, 0x86, 0x0e, 0x48, 0x78, 0x8a, 0x21, 0x0e, 0xf3, 0x8a, 0x63, 0x36, 0xf4, 0x02, 0x9e, 0xae, 0xf5, 0x7a, 0xd0, 0xb8, 0x99, 0x48, 0xa3, 0xad},
                             {0xd5, 0x18, 0x53, 0x4e, 0xa4, 0x8a, 0x2d, 0x86, 0xc4, 0xbd, 0x36, 0xb8, 0x02, 0x5e, 0x78, 0xd1, 0x24, 0x79, 0x0e, 0xd9, 0x22, 0x0a, 0x72, 0xfb, 0xbc, 0xa2, 0xbe, 0x54, 0x83, 0xd8, 0x75, 0x9e},
                             {0xfe, 0x2f, 0x6c, 0xe2, 0x49, 0x55, 0x3a, 0x1b, 0x4a, 0x9f, 0xd9, 0xfb, 0x9e, 0x90, 0xb8, 0x40, 0x71, 0xab, 0x63, 0x66, 0xcd, 0xee, 0x92, 0x17, 0xe2, 0xe6, 0xb4, 0xb4, 0xc2, 0x9b, 0x32, 0x75},
                             {0x96, 0xd2, 0x15, 0xac, 0x18, 0xa1, 0x73, 0xd2, 0x62, 0x2a, 0x60, 0x86, 0x0a, 0x92, 0x82, 0xe4, 0x79, 0x28, 0xbe, 0xb0, 0xc8, 0xc4, 0x2c, 0x64, 0xad, 0x06, 0x8c, 0x9b, 0x17, 0x02, 0x90, 0xab},
                             {0x26, 0x98, 0x1a, 0xe5, 0x12, 0x81, 0x5b, 0xd5, 0x8a, 0x34, 0x87, 0xba, 0x81, 0x85, 0x54, 0xd9, 0x4d, 0xc8, 0x1c, 0x2a, 0xea, 0xad, 0x38, 0x85, 0xe8, 0x30, 0xc9, 0x5e, 0xf7, 0x8a, 0x8e, 0x30},
                             {0x6c, 0xa2, 0xdf, 0x2c, 0x5a, 0x14, 0x76, 0x62, 0x04, 0x57, 0xc3, 0x18, 0xad, 0x07, 0x62, 0x56, 0x37, 0xe5, 0xc6, 0x0d, 0xcd, 0xad, 0xfd, 0x0f, 0x16, 0x21, 0x00, 0x0e, 0xb0, 0x15, 0x1d, 0x95}
};

float kernel[KERNEL_HEIGHT][KERNEL_WIDTH] = {
		{0x12, 0x11},
		{0x39, 0x43}
};

float kernel1[KERNEL_HEIGHT][KERNEL_WIDTH] = {
		{0x12, 0x11},
		{0x39, 0x43}
};

double output[OUTPUT_HEIGHT][OUTPUT_WIDTH];

double output1[OUTPUT_HEIGHT][OUTPUT_WIDTH];

#define HOPS 3
#define SINGLE_CORE_MODE 0
#define DUAL_CORE_MODE 1
#define LOW_LEVEL_PHEROMONE 200
#define HIGH_LEVEL_PHEROMONE 800
#define PHEROMONE_UP_STEP 2
#define PHEROMONE_DOWN_STEP 600
#define PHEROMONE_MAX_LEVEL 1000
#define PHEROMONE_MIN_LEVEL 0
uint8_t mode = SINGLE_CORE_MODE;
uint16_t pheromone = PHEROMONE_MIN_LEVEL;


/***** Functions *****/
//static void gpio_isr(void *cbdata)
//{
//    mxc_gpio_cfg_t *cfg = cbdata;
//    MXC_GPIO_OutToggle(cfg->port, cfg->mask);
//}

/*
 *  Switch the system clock to the HIRC / 4
 *
 *  Enable the HIRC, set the divide ration to /4, and disable the 96 MHz oscillator.
 */


volatile int buttonPressed = 0;
void buttonHandler(void *pb)
{
    buttonPressed = 1;
}

void setTrigger(int waitForTrigger)
{
    int tmp;

    buttonPressed = 0;
    if (waitForTrigger) {
        while (!buttonPressed) {}
    }

    // Debounce the button press.
    for (tmp = 0; tmp < 0x800000; tmp++) {
        __NOP();
    }

// Wait for serial transactions to complete.

    while (MXC_UART_ReadyForSleep(MXC_UART_GET_UART(CONSOLE_UART)) != E_NO_ERROR) {}

}

void switchToHIRCD4(void)
{
    MXC_SETFIELD(MXC_GCR->clkcn, MXC_F_GCR_CLKCN_PSC, MXC_S_GCR_CLKCN_PSC_DIV4);
    MXC_GCR->clkcn |= MXC_F_GCR_CLKCN_HIRC_EN;
    MXC_SETFIELD(MXC_GCR->clkcn, MXC_F_GCR_CLKCN_CLKSEL, MXC_S_GCR_CLKCN_CLKSEL_HIRC);
    /* Disable unused clocks */
    while (!(MXC_GCR->clkcn & MXC_F_GCR_CLKCN_CKRDY)) {}
    /* Wait for the switch to occur */
    MXC_GCR->clkcn &= ~(MXC_F_GCR_CLKCN_HIRC96M_EN);
    SystemCoreClockUpdate();
}

/*
 *  Switch the system clock to the HIRC96
 *
 *  Enable the HIRC, set the divide ration to /1, and disable the 60 MHz oscillator.
 */
void switchToHIRC96(void)
{
    MXC_SETFIELD(MXC_GCR->clkcn, MXC_F_GCR_CLKCN_PSC, MXC_S_GCR_CLKCN_PSC_DIV1);
    MXC_GCR->clkcn |= MXC_F_GCR_CLKCN_HIRC96M_EN;
    MXC_SETFIELD(MXC_GCR->clkcn, MXC_F_GCR_CLKCN_CLKSEL, MXC_S_GCR_CLKCN_CLKSEL_HIRC96);
    /* Disable unused clocks */
    while (!(MXC_GCR->clkcn & MXC_F_GCR_CLKCN_CKRDY)) {}
    /* Wait for the switch to occur */
    MXC_GCR->clkcn &= ~(MXC_F_GCR_CLKCN_HIRC_EN);
    SystemCoreClockUpdate();
}

void prepForDeepSleep(void)
{
    MXC_ICC_Disable();
    MXC_LP_ICache0Shutdown();

    /* Shutdown unused power domains */
    MXC_PWRSEQ->lpcn |= MXC_F_PWRSEQ_LPCN_BGOFF;

    /* Prevent SIMO soft start on wakeup */
    MXC_LP_FastWakeupDisable();

    /* Enable VDDCSWEN=1 prior to enter backup/deepsleep mode */
    MXC_MCR->ctrl |= MXC_F_MCR_CTRL_VDDCSWEN;

    switchToHIRCD4();

    MXC_SIMO_SetVregO_B(810); /* Reduce VCOREB to 0.81v */
}

void recoverFromDeepSleep(void)
{
    /* Check to see if VCOREA is ready on  */
    if (!(MXC_SIMO->buck_out_ready & MXC_F_SIMO_BUCK_OUT_READY_BUCKOUTRDYC)) {
        /* Wait for VCOREB to be ready */
        while (!(MXC_SIMO->buck_out_ready & MXC_F_SIMO_BUCK_OUT_READY_BUCKOUTRDYB)) {}

        /* Move VCORE switch back to VCOREB */
        MXC_MCR->ctrl = (MXC_MCR->ctrl & ~(MXC_F_MCR_CTRL_VDDCSW)) |
                        (0x1 << MXC_F_MCR_CTRL_VDDCSW_POS);

        /* Raise the VCORE_B voltage */
        while (!(MXC_SIMO->buck_out_ready & MXC_F_SIMO_BUCK_OUT_READY_BUCKOUTRDYB)) {}
        MXC_SIMO_SetVregO_B(1000);
        while (!(MXC_SIMO->buck_out_ready & MXC_F_SIMO_BUCK_OUT_READY_BUCKOUTRDYB)) {}
    }

    MXC_LP_ICache0PowerUp();
    MXC_ICC_Enable();

    switchToHIRC96();
}
volatile int sleep_mode = 0;
volatile int backup_mode = 0;
volatile int adaptive_mode = 0;
static void enter_deepsleep_isr(){
	sleep_mode = 1;
}
static void enter_backup_isr(){
	backup_mode = 1;
}

//******************************************************************************
/***** Definitions *****/
#define TESTSIZE 8192 //2 pages worth so we can do erase functions

#define MXC_FLASH_MEM_SIZE_TEST 2 * MXC_FLASH_MEM_SIZE

/***** Globals *****/
uint32_t testaddr;
uint32_t testdata[TESTSIZE];
volatile uint32_t isr_cnt;
volatile uint32_t isr_flags;

void FLC0_IRQHandler(void)
{
    uint32_t temp;
    isr_cnt++;
    temp = MXC_FLC0->intr;

    if (temp & MXC_F_FLC_INTR_DONE) {
        MXC_FLC0->intr &= ~MXC_F_FLC_INTR_DONE;
    }

    if (temp & MXC_F_FLC_INTR_AF) {
        MXC_FLC0->intr &= ~MXC_F_FLC_INTR_AF;
    }

    isr_flags = temp;
}

void FLC1_IRQHandler(void)
{
    uint32_t temp;
    isr_cnt++;
    temp = MXC_FLC1->intr;

    if (temp & MXC_F_FLC_INTR_DONE) {
        MXC_FLC1->intr &= ~MXC_F_FLC_INTR_DONE;
    }

    if (temp & MXC_F_FLC_INTR_AF) {
        MXC_FLC1->intr &= ~MXC_F_FLC_INTR_AF;
    }

    isr_flags = temp;
}

//******************************************************************************
void flash_init(void)
{
    // Set flash clock divider to generate a 1MHz clock from the APB clock
    // APB clock is 54MHz on the real silicon
    MXC_FLC0->clkdiv = 24;
    MXC_FLC1->clkdiv = 24;

    // Setup and enable interrupt
    MXC_FLC_ClearFlags(0x3);
    MXC_NVIC_SetVector(FLC0_IRQn, FLC0_IRQHandler);
    NVIC_EnableIRQ(FLC0_IRQn);

    MXC_NVIC_SetVector(FLC1_IRQn, FLC1_IRQHandler);
    NVIC_EnableIRQ(FLC1_IRQn);
}

//******************************************************************************
void interrupt_enabler(mxc_flc_regs_t *regs)
{
    regs->intr = (MXC_F_FLC_INTR_DONEIE | MXC_F_FLC_INTR_AFIE);
}

struct backup_data{
	uint32_t count;
	uint8_t i;
	uint8_t j;
	uint8_t n;
	uint8_t m;
};
struct backup_data backupData;

volatile int after_restore = 0;
volatile uint32_t pow_fails = 0;

#define FLASH1_BACKUP_ADDR 	MXC_FLASH1_MEM_BASE+4

void checkpoint(){
	uint8_t it = 10;
	while(it){
		MXC_FLC_PageErase(FLASH1_BACKUP_ADDR);
		MXC_FLC_Write(FLASH1_BACKUP_ADDR, sizeof(backupData), (uint32_t*)&backupData);
		it--;
	}
	printf("CNT before power failure = %d\n", backupData.count);
	printf("Checkpoint\n");
}

void restore(){
	uint8_t it = 10;
	while(it){
		MXC_FLC_Read(FLASH1_BACKUP_ADDR, &backupData, sizeof(backupData));
		it--;
	}
	//after_restore = 1;
	printf("Restore\n");
	printf("CNT after restore = %d\n", backupData.count);
}

void enter_deepsleep(){
//	if(adaptive_mode)
//		pheromone = pheromone < PHEROMONE_DOWN_STEP ? PHEROMONE_MIN_LEVEL : pheromone - PHEROMONE_DOWN_STEP;
	printf("Entering DEEPSLEEP mode. Count - %d\n", backupData.count);
	//setTrigger(0);
	while (MXC_UART_ReadyForSleep(MXC_UART_GET_UART(CONSOLE_UART)) != E_NO_ERROR) {}
	prepForDeepSleep();
	MXC_LP_EnterDeepSleepMode();
	recoverFromDeepSleep();
	printf("Waking up from DEEPSLEEP mode. Count - %d\n", backupData.count);
	sleep_mode = 0;
}

void enter_backup(){
	if(adaptive_mode)
		pheromone = pheromone < PHEROMONE_DOWN_STEP ? PHEROMONE_MIN_LEVEL : pheromone - PHEROMONE_DOWN_STEP;
	backup_mode = 0;
	pow_fails++;
	checkpoint();
	printf("Entering BACKUP mode.\n");
	while (MXC_UART_ReadyForSleep(MXC_UART_GET_UART(CONSOLE_UART)) != E_NO_ERROR) {}
    prepForDeepSleep();
    MXC_LP_EnterDeepSleepMode();
	recoverFromDeepSleep();
	printf("Waking up from BACKUP mode.\n");
	restore();
}

uint32_t core1_count;

void switchToSingleCoreMode(mxc_gpio_cfg_t gpio_single, mxc_gpio_cfg_t gpio_dual){
	MXC_GPIO_OutClr(gpio_dual.port, gpio_dual.mask);
	MXC_GPIO_OutSet(gpio_single.port, gpio_single.mask);
	mode = SINGLE_CORE_MODE;
	printf("Switched to SINGLE CORE MODE\n");
}

void switchToDualCoreMode(mxc_gpio_cfg_t gpio_single, mxc_gpio_cfg_t gpio_dual){
	MXC_GPIO_OutClr(gpio_single.port, gpio_single.mask);
	MXC_GPIO_OutSet(gpio_dual.port, gpio_dual.mask);
	mode = DUAL_CORE_MODE;
	printf("Switched to DUAL CORE MODE\n");
}

int main(void)
{
//    mxc_gpio_cfg_t gpio_in;
//    mxc_gpio_cfg_t gpio_out;
	mxc_gpio_cfg_t gpio_out_single;
	mxc_gpio_cfg_t gpio_out_dual;
    mxc_gpio_cfg_t gpio_interrupt_sleep;
    mxc_gpio_cfg_t gpio_interrupt_wakeup;
    mxc_gpio_cfg_t gpio_interrupt_backup;
//    mxc_gpio_cfg_t gpio_interrupt_status;

    printf("\n\n****** GPIO Example ******\n");
    printf("Demonstrates GPIO get/set and interrupt usage\n");

    printf("1. This example reads P1.10 (SW1) and outputs the same state onto P0.29 (LED0).\n");
    printf("2. An interrupt is set up on P0.16. When interrupt occurs P0.30 (LED1) toggles.\n\n");

    PB_RegisterCallback(0, (pb_callback)buttonHandler);
    MXC_LP_EnableGPIOWakeup((mxc_gpio_cfg_t *)&pb_pin[0]);

//    /* Setup interrupt status pin as an output so we can toggle it on each interrupt. */
//    gpio_interrupt_status.port = MXC_GPIO_PORT_INTERRUPT_STATUS;
//    gpio_interrupt_status.mask = MXC_GPIO_PIN_INTERRUPT_STATUS;
//    gpio_interrupt_status.pad = MXC_GPIO_PAD_NONE;
//    gpio_interrupt_status.func = MXC_GPIO_FUNC_OUT;
//    gpio_interrupt_status.vssel = MXC_GPIO_VSSEL_VDDIO;
//    MXC_GPIO_Config(&gpio_interrupt_status);

    /*
  *   Set up interrupt on MXC_GPIO_PORT_INTERRUPT_IN.
  *   Switch on EV kit is open when non-pressed, and grounded when pressed.  Use an internal pull-up so pin
  *     reads high when button is not pressed.
  */
//    gpio_interrupt_sleep.port = MXC_GPIO_PORT_INTERRUPT_IN_SLEEP;
//    gpio_interrupt_sleep.mask = MXC_GPIO_PIN_INTERRUPT_IN_SLEEP;
//    gpio_interrupt_sleep.pad = MXC_GPIO_PAD_PULL_UP;
//    gpio_interrupt_sleep.func = MXC_GPIO_FUNC_IN;
//    gpio_interrupt_sleep.vssel = MXC_GPIO_VSSEL_VDDIO;
//    MXC_GPIO_RegisterCallback(&gpio_interrupt_sleep, enter_deepsleep_isr, NULL);
//    MXC_GPIO_IntConfig(&gpio_interrupt_sleep, MXC_GPIO_INT_FALLING);
//    MXC_GPIO_EnableInt(gpio_interrupt_sleep.port, gpio_interrupt_sleep.mask);
//    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO_PORT_INTERRUPT_IN_SLEEP)));

    gpio_interrupt_wakeup.port = MXC_GPIO_PORT_INTERRUPT_IN_WAKEUP;
    gpio_interrupt_wakeup.mask = MXC_GPIO_PIN_INTERRUPT_IN_WAKEUP;
    gpio_interrupt_wakeup.pad = MXC_GPIO_PAD_PULL_UP;
    gpio_interrupt_wakeup.func = MXC_GPIO_FUNC_IN;
    gpio_interrupt_wakeup.vssel = MXC_GPIO_VSSEL_VDDIO;
//    MXC_GPIO_RegisterCallback(&gpio_interrupt_wakeup, exit_deepsleep_isr, NULL);
    MXC_GPIO_IntConfig(&gpio_interrupt_wakeup, MXC_GPIO_INT_RISING);
    MXC_GPIO_EnableInt(gpio_interrupt_wakeup.port, gpio_interrupt_wakeup.mask);
    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO_PORT_INTERRUPT_IN_WAKEUP)));
    MXC_LP_EnableGPIOWakeup((mxc_gpio_cfg_t *)&gpio_interrupt_wakeup);

    gpio_interrupt_sleep.port = MXC_GPIO_PORT_INTERRUPT_IN_DEEPSLEEP;
    gpio_interrupt_sleep.mask = MXC_GPIO_PIN_INTERRUPT_IN_DEEPSLEEP;
    gpio_interrupt_sleep.pad = MXC_GPIO_PAD_PULL_UP;
    gpio_interrupt_sleep.func = MXC_GPIO_FUNC_IN;
    gpio_interrupt_sleep.vssel = MXC_GPIO_VSSEL_VDDIO;
    MXC_GPIO_RegisterCallback(&gpio_interrupt_sleep, enter_deepsleep_isr, NULL);
    MXC_GPIO_IntConfig(&gpio_interrupt_sleep, MXC_GPIO_INT_FALLING);
    MXC_GPIO_EnableInt(gpio_interrupt_sleep.port, gpio_interrupt_sleep.mask);
    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO_PORT_INTERRUPT_IN_DEEPSLEEP)));

    gpio_interrupt_backup.port = MXC_GPIO_PORT_INTERRUPT_IN_BACKUP;
    gpio_interrupt_backup.mask = MXC_GPIO_PIN_INTERRUPT_IN_BACKUP;
    gpio_interrupt_backup.pad = MXC_GPIO_PAD_PULL_UP;
    gpio_interrupt_backup.func = MXC_GPIO_FUNC_IN;
    gpio_interrupt_backup.vssel = MXC_GPIO_VSSEL_VDDIO;
    MXC_GPIO_RegisterCallback(&gpio_interrupt_backup, enter_backup_isr, NULL);
    MXC_GPIO_IntConfig(&gpio_interrupt_backup, MXC_GPIO_INT_FALLING);
    MXC_GPIO_EnableInt(gpio_interrupt_backup.port, gpio_interrupt_backup.mask);
    NVIC_EnableIRQ(MXC_GPIO_GET_IRQ(MXC_GPIO_GET_IDX(MXC_GPIO_PORT_INTERRUPT_IN_BACKUP)));
    MXC_LP_EnableGPIOWakeup((mxc_gpio_cfg_t *)&gpio_interrupt_backup);

    /* Note: This example must execute out of RAM, due to MXC_FLC_MassErase() call, below */
    printf("\n\n***** Flash Control Example *****\n");
    NVIC_SetRAM();
    // Initialize the Flash
    flash_init();

    // Clear and enable flash programming interrupts
    interrupt_enabler(MXC_FLC0);
    interrupt_enabler(MXC_FLC1);
    isr_flags = 0;
    isr_cnt = 0;

    /*
  *   Setup input pin.
  *   Switch on EV kit is open when non-pressed, and grounded when pressed.  Use an internal pull-up so pin
  *	    reads high when button is not pressed.
  */
//    gpio_in.port = MXC_GPIO_PORT_IN;
//    gpio_in.mask = MXC_GPIO_PIN_IN;
//    gpio_in.pad = MXC_GPIO_PAD_PULL_UP;
//    gpio_in.func = MXC_GPIO_FUNC_IN;
//    MXC_GPIO_Config(&gpio_in);
//
//    /* Setup output pin. */
//    gpio_out.port = MXC_GPIO_PORT_OUT;
//    gpio_out.mask = MXC_GPIO_PIN_OUT;
//    gpio_out.pad = MXC_GPIO_PAD_NONE;
//    gpio_out.func = MXC_GPIO_FUNC_OUT;
//    //gpio_out.vssel = MXC_GPIO_VSSEL_VDDIO;
//    MXC_GPIO_Config(&gpio_out);

    gpio_out_single.port = MXC_GPIO_PORT_OUT_SINGLE;
    gpio_out_single.mask = MXC_GPIO_PIN_OUT_SINGLE;
    gpio_out_single.pad = MXC_GPIO_PAD_NONE;
    gpio_out_single.func = MXC_GPIO_FUNC_OUT;
    //gpio_out.vssel = MXC_GPIO_VSSEL_VDDIO;
    MXC_GPIO_Config(&gpio_out_single);
    MXC_GPIO_OutClr(gpio_out_single.port, gpio_out_single.mask);


    gpio_out_dual.port = MXC_GPIO_PORT_OUT_DUAL;
    gpio_out_dual.mask = MXC_GPIO_PIN_OUT_DUAL;
    gpio_out_dual.pad = MXC_GPIO_PAD_NONE;
    gpio_out_dual.func = MXC_GPIO_FUNC_OUT;
    //gpio_out.vssel = MXC_GPIO_VSSEL_VDDIO;
    MXC_GPIO_Config(&gpio_out_dual);
    MXC_GPIO_OutClr(gpio_out_dual.port, gpio_out_dual.mask);

    MXC_Delay(5000);

    ////***** Code for measuring time for PEARL operatioons ******///
//    MXC_RTC_Init(0, 0);
//    MXC_RTC_Start();
//    volatile float pwr[] = {28};
//    volatile float alpha = 0.5;
//    for(int i = 0; i < 1000000; i++){
//    	//pwr[0] = (1-alpha)*pwr[0] + alpha*(pwr[0]+1);
//    	if (pwr[0] > 3 && pwr[0] > 50)
//    		pwr[0] = pwr[0]+1;
//    	else if (pwr[0] > 50 && pwr[0] > 100)
//    		pwr[0] = pwr[0]+2;
//    	else pwr[0] = pwr[0] + 3;
//    }
//
//
//    MXC_RTC_Stop();
//	int sss = MXC_RTC_GetSecond();
//	int ssss = MXC_RTC_GetSubSecond();
//	printf("P = %f\n", pwr[0]);
//	printf("sss = %d, ssss = %d\n", sss, ssss);
//
//	return 0;
	////***** End of Code for measuring time for PEARL operatioons ******///


//
//    while (1) {
//        /* Read state of the input pin. */
//        if (MXC_GPIO_InGet(gpio_in.port, gpio_in.mask)) {
//            /* Input pin was high, set the output pin. */
//            MXC_GPIO_OutSet(gpio_out.port, gpio_out.mask);
//        } else {
//            /* Input pin was low, clear the output pin. */
//            MXC_GPIO_OutClr(gpio_out.port, gpio_out.mask);
//        }
//    }

//    printf("Entering INIT DEEPSLEEP mode.\n");
//	setTrigger(0);
//	prepForDeepSleep();
//	MXC_LP_EnterDeepSleepMode();
//	recoverFromDeepSleep();
//	printf("Waking up from INIT DEEPSLEEP mode.\n");

//	mxc_tmr_cfg_t tmr;
//    tmr.pres = TMR_PRES_1;
//    tmr.mode = TMR_MODE_CONTINUOUS;
//    tmr.pol = 0;

//	volatile uint32_t c = 0;
//	volatile uint32_t t;
	volatile uint8_t sec;
	volatile uint32_t macops;
#if SINGLE_CORE_EXPERIMENT
	//MXC_TMR_Init(MXC_TMR0, &tmr);
	MXC_RTC_Init(0, 0);

	backupData.count = 0;

	/****** START OF SINGLE-CORE EXECUTION ******/
	printf("Start SINGLE-CORE computation\n");

	switchToSingleCoreMode(gpio_out_single, gpio_out_dual);
	MXC_RTC_Start();
	while(1){
		//MXC_GPIO_OutSet(gpio_out.port, gpio_out.mask);
		uint8_t i = after_restore ? backupData.i : 0;
    	for(; i < OUTPUT_HEIGHT; i++){
    		backupData.i = i;
    		uint8_t j = after_restore ? backupData.j : 0;
    		for(; j < OUTPUT_WIDTH; j++){
    			backupData.j = j;
    			double sum = 0;
    			uint8_t n = after_restore ? backupData.n : 0;
    			for(; n < KERNEL_HEIGHT; n++){
    				backupData.n = n;
    				uint8_t m = after_restore ? backupData.m : 0;
    				for(; m < KERNEL_WIDTH; m++){
    					backupData.m = m;
    					after_restore = 0;
    					if (sleep_mode){
    						enter_deepsleep();
    					} else if(backup_mode){
    						enter_backup();
    					} else{
    						sum += (double) kernel[n][m] * (double) input[n+i][m+j];
    					}
    				}
    			}
    			output[i][j] = sum + ((double)rand()/(double)(RAND_MAX)) * (double)0.999;
    			backupData.count++;
    		}
    	}
    	//MXC_TMR_Stop(MXC_TMR0);

    	if (MXC_RTC_GetSecond() >= 60){
    		MXC_RTC_Stop();
    		sec = MXC_RTC_GetSecond();
    		sec += (MXC_RTC_GetSubSecond()/4096.0);
    		macops = (backupData.count)/sec;
    		break;
    	}

    	//c = MXC_TMR_GetCount(MXC_TMR0);
    	//MXC_GPIO_OutClr(gpio_out.port, gpio_out.mask);
    	//MXC_TMR_GetTime(MXC_TMR0, PeripheralClock, &t, 0);
    }
	printf("Complete computation\n");
	printf("MACOPS = %d, Power failures = %d\n", macops, pow_fails);

	int p = HOPS;
    while(p){
    	printf("Entering PREPREFINAL DEEPSLEEP mode.\n");
		setTrigger(0);
		prepForDeepSleep();
		MXC_LP_EnterDeepSleepMode();
		recoverFromDeepSleep();
		printf("Waking up from PREPREFINAL DEEPSLEEP mode.\n");
		p--;
    }
    /****** END OF SINGLE-CORE EXECUTION ******/
#endif //SINGLE_CORE_EXPERIMENT

#if DUAL_CORE_EXPERIMENT
    /****** START OF DUAL-CORE EXECUTION ******/

    pow_fails = 0;
    backupData.count = 0;
    MXC_RTC_Init(0, 0);

	printf("Start DUAL-CORE computation\n");

	switchToDualCoreMode(gpio_out_single, gpio_out_dual);
	MXC_RTC_Start();
	Core1_Start();
	while(1){
		uint8_t i = 0;
    	for(; i < (OUTPUT_HEIGHT/2); i++){
    		backupData.i = i;
    		uint8_t j = 0;
    		for(; j < OUTPUT_WIDTH; j++){
    			backupData.j = j;
    			double sum = 0;
    			uint8_t n = 0;
    			for(; n < KERNEL_HEIGHT; n++){
    				backupData.n = n;
    				uint8_t m = 0;
    				for(; m < KERNEL_WIDTH; m++){
    					backupData.m = m;
    					after_restore = 0;
    					if (sleep_mode){
    						Core1_Stop();
    						enter_deepsleep();
    						Core1_Start();
    					} else if(backup_mode){
    						Core1_Stop();
    						enter_backup();
    						Core1_Start();
    					} else{
    						sum += (double) kernel[n][m] * (double) input[n+i][m+j];
    					}
    				}
    			}
    			output[i][j] = sum + ((double)rand()/(double)(RAND_MAX)) * (double)0.999;
    			backupData.count++;
    			backupData.count++;
    		}
    	}
    	if (MXC_RTC_GetSecond() >= 60){
    		MXC_RTC_Stop();
			Core1_Stop();
    		sec = MXC_RTC_GetSecond();
    		sec += (MXC_RTC_GetSubSecond()/4096.0);
    		macops = (backupData.count)/sec;
    		break;
    	}
    }

	printf("Complete DUAL-CORE computation\n");
	printf("MACOPS = %d, Power failures = %d\n", macops, pow_fails);

	int r = HOPS;
    while(r){
    	printf("Entering PREFINAL DEEPSLEEP mode.\n");
		setTrigger(0);
		prepForDeepSleep();
		MXC_LP_EnterDeepSleepMode();
		recoverFromDeepSleep();
		printf("Waking up from PREFINAL DEEPSLEEP mode.\n");
		r--;
    }

	/****** END OF DUAL-CORE EXECUTION ******/
#endif //    DUAL_CORE_EXPERIMENT

#if ADAPTIVE_EXPERIMENT
    /****** START OF ADAPTIVE EXECUTION ******/

    adaptive_mode = 1;
    pow_fails = 0;
    backupData.count = 0;
    MXC_RTC_Init(0, 0);

	printf("Start ADAPTIVE computation\n");
	switchToSingleCoreMode(gpio_out_single, gpio_out_dual);

	MXC_RTC_Start();
	while(1){
		pheromone = pheromone + PHEROMONE_UP_STEP >= PHEROMONE_MAX_LEVEL ? PHEROMONE_MAX_LEVEL : pheromone + PHEROMONE_UP_STEP;
		//printf("Pheromone = %d\n", pheromone);
		if(mode == SINGLE_CORE_MODE && pheromone >= HIGH_LEVEL_PHEROMONE) {
			switchToDualCoreMode(gpio_out_single, gpio_out_dual);
			Core1_Start();
		} else if (mode == DUAL_CORE_MODE && pheromone <= LOW_LEVEL_PHEROMONE) {
			Core1_Stop();
			switchToSingleCoreMode(gpio_out_single, gpio_out_dual);
		}


		uint8_t i = 0;
    	for(; i < (OUTPUT_HEIGHT); i++){
    		backupData.i = i;
    		uint8_t j = 0;
    		for(; j < OUTPUT_WIDTH; j++){
    			backupData.j = j;
    			double sum = 0;
    			uint8_t n = 0;
    			for(; n < KERNEL_HEIGHT; n++){
    				backupData.n = n;
    				uint8_t m = 0;
    				for(; m < KERNEL_WIDTH; m++){
    					backupData.m = m;
    					after_restore = 0;
    					if (sleep_mode){
    						if (mode == DUAL_CORE_MODE) Core1_Stop();
    						enter_deepsleep();
    						if (mode == DUAL_CORE_MODE) Core1_Start();
    					} else if(backup_mode){
    						if (mode == DUAL_CORE_MODE) Core1_Stop();
    						enter_backup();
    						if (mode == DUAL_CORE_MODE) Core1_Start();
    					} else{
    						sum += (double) kernel[n][m] * (double) input[n+i][m+j];
    					}
    				}
    			}
    			output[i][j] = sum + ((double)rand()/(double)(RAND_MAX)) * (double)0.999;
    			backupData.count++;
    			if (mode == DUAL_CORE_MODE) backupData.count++;
    		}
    	}
    	if (MXC_RTC_GetSecond() >= 60){
        	MXC_RTC_Stop();
        	if (mode == DUAL_CORE_MODE) Core1_Stop();
    		sec = MXC_RTC_GetSecond();
    		sec += (MXC_RTC_GetSubSecond()/4096.0);
    		macops = (backupData.count)/sec;
    		break;
    	}
    }

	adaptive_mode = 0;
	printf("Complete ADAPTIVE computation\n");
	printf("MACOPS = %d, Power failures = %d\n", macops, pow_fails);
    /****** END OF ADAPTIVE EXECUTION ******/
#endif //ADAPRIVE_EXPERIMENT

    while(1){
    	printf("Entering FINAL DEEPSLEEP mode.\n");
		setTrigger(0);
		prepForDeepSleep();
		MXC_LP_EnterDeepSleepMode();
		recoverFromDeepSleep();
		printf("Waking up from FINAL DEEPSLEEP mode.\n");
    }

    return 0;
}

int Core1_Main(){
	core1_count = 0;

	while(1){
    	for(uint8_t i = (OUTPUT_HEIGHT/2)+1; i < OUTPUT_HEIGHT; i++){
    		for(uint8_t j = 0; j < OUTPUT_WIDTH; j++){
    			double sum = 0;
    			for(uint8_t n = 0; n < KERNEL_HEIGHT; n++){
    				for(uint8_t m = 0; m < KERNEL_WIDTH; m++){
    					sum+= (double) kernel1[n][m] * (double) input1[n+i][m+j];
    				}
    			}
    			output1[i][j] = sum + ((double)rand()/(double)(RAND_MAX)) * (double)0.999;
    			//core1_count++;
    		}
    	}
	}


	return 0;
}
